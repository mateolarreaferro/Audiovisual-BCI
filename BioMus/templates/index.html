<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>BioMus - Neural Audio Interface</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      /* Minimal White & Black Theme - Professional & Clean */
      --bg-primary: #FFFFFF;
      --bg-secondary: #FAFAFA;
      --bg-tertiary: #F5F5F5;
      --bg-elevated: #FFFFFF;

      /* Accent colors - for visualizations */
      --accent-blue: #2AA3FE;
      --accent-green: #10B978;
      --accent-purple: #B743C6;
      --accent-orange: #F58633;

      /* Neutrals - grayscale inverted */
      --neutral-900: #000000;
      --neutral-800: #1A1A1A;
      --neutral-700: #333333;
      --neutral-600: #666666;
      --neutral-500: #999999;
      --neutral-400: #B3B3B3;
      --neutral-300: #CCCCCC;
      --neutral-200: #E0E0E0;
      --neutral-100: #F5F5F5;

      /* Semantic colors */
      --text-primary: #000000;
      --text-secondary: #666666;
      --text-tertiary: #999999;
      --success: #000000;
      --error: #000000;
      --warning: #000000;

      /* Borders & shadows */
      --border-light: #E0E0E0;
      --border-medium: #CCCCCC;
      --shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.08);
      --shadow-md: 0 4px 12px rgba(0, 0, 0, 0.12);
      --shadow-lg: 0 10px 24px rgba(0, 0, 0, 0.15);
      --shadow-xl: 0 20px 40px rgba(0, 0, 0, 0.2);

      /* Radius */
      --radius-sm: 4px;
      --radius-md: 8px;
      --radius-lg: 12px;
      --radius-xl: 16px;
      --radius-full: 9999px;

      /* Spacing - Reduced for compact layout */
      --space-xs: 4px;
      --space-sm: 6px;
      --space-md: 10px;
      --space-lg: 14px;
      --space-xl: 18px;
      --space-2xl: 24px;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: var(--bg-secondary);
      color: var(--text-primary);
      height: 100vh;
      display: flex;
      line-height: 1.5;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      overflow: hidden;
    }

    /* Sidebar */
    .sidebar {
      width: 280px;
      background: var(--bg-primary);
      border-right: 1px solid var(--border-light);
      padding: var(--space-lg) var(--space-md);
      display: flex;
      flex-direction: column;
      gap: var(--space-lg);
      overflow-y: auto;
      height: 100vh;
    }

    .brand {
      display: flex;
      flex-direction: column;
      gap: var(--space-sm);
      padding-bottom: var(--space-lg);
      border-bottom: 1px solid var(--border-light);
    }

    .brand-header {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .brand-logo {
      width: 48px;
      height: 48px;
      border-radius: var(--radius-md);
      background: var(--bg-elevated);
      border: 1px solid var(--border-light);
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 700;
      font-size: 20px;
      color: var(--text-primary);
    }

    .brand-text h1 {
      font-size: 24px;
      font-weight: 700;
      color: var(--text-primary);
      letter-spacing: -0.02em;
    }

    .brand-text .tagline {
      font-size: 12px;
      color: var(--text-secondary);
      font-weight: 500;
      margin-top: 2px;
    }

    .brand-credit {
      font-size: 11px;
      color: var(--text-tertiary);
      font-weight: 400;
      margin-top: var(--space-xs);
    }

    .section {
      display: flex;
      flex-direction: column;
      gap: var(--space-sm);
    }

    .section-label {
      font-size: 10px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      color: var(--text-tertiary);
    }

    .card {
      background: var(--bg-elevated);
      border: 1px solid var(--border-light);
      border-radius: var(--radius-md);
      padding: var(--space-md);
      box-shadow: var(--shadow-sm);
      transition: all 0.2s ease;
    }

    .card:hover {
      box-shadow: var(--shadow-md);
    }

    .card-header {
      display: flex;
      align-items: flex-start;
      gap: 10px;
      margin-bottom: var(--space-sm);
    }

    .step-badge {
      width: 32px;
      height: 32px;
      border-radius: var(--radius-md);
      background: var(--bg-elevated);
      border: 1px solid var(--border-light);
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 700;
      font-size: 14px;
      color: var(--text-primary);
      flex-shrink: 0;
    }

    .card-title-group {
      flex: 1;
    }

    .card-title {
      font-size: 14px;
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: 2px;
    }

    .card-subtitle {
      font-size: 12px;
      color: var(--text-secondary);
      line-height: 1.4;
    }

    .status-indicator {
      width: 12px;
      height: 12px;
      border-radius: var(--radius-full);
      background: var(--neutral-300);
      position: relative;
      flex-shrink: 0;
    }

    .status-indicator.connected {
      background: var(--text-primary);
      box-shadow: 0 0 0 4px rgba(0, 0, 0, 0.1);
      animation: pulse 2s ease-in-out infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }

    .info-box {
      background: var(--bg-tertiary);
      border: 1px solid var(--border-light);
      border-radius: var(--radius-md);
      padding: 12px;
      font-size: 12px;
      line-height: 1.6;
      color: var(--text-secondary);
      margin-bottom: var(--space-md);
    }

    .info-box strong {
      color: var(--text-primary);
      font-weight: 600;
    }

    .field-group {
      margin-bottom: var(--space-md);
    }

    .field-label {
      font-size: 13px;
      font-weight: 500;
      color: var(--text-secondary);
      margin-bottom: var(--space-sm);
      display: block;
    }

    input[type="text"],
    input[type="number"] {
      width: 100%;
      padding: 8px 12px;
      border-radius: var(--radius-md);
      border: 1px solid var(--border-light);
      background: var(--bg-primary);
      color: var(--text-primary);
      font-size: 13px;
      font-family: inherit;
      transition: all 0.2s ease;
    }

    input:focus {
      outline: none;
      border-color: var(--text-primary);
      box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.05);
    }

    input::placeholder {
      color: var(--text-tertiary);
    }

    .input-row {
      display: flex;
      gap: var(--space-sm);
    }

    .btn {
      padding: 8px 16px;
      border-radius: var(--radius-full);
      font-size: 13px;
      font-weight: 600;
      font-family: inherit;
      cursor: pointer;
      transition: all 0.2s ease;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      white-space: nowrap;
      border: none;
      outline: none;
    }

    .btn-primary {
      background: var(--text-primary);
      color: var(--bg-primary);
      border: 1px solid var(--text-primary);
      box-shadow: var(--shadow-sm);
    }

    .btn-primary:hover {
      background: var(--neutral-800);
      border-color: var(--neutral-800);
      color: var(--bg-primary);
      box-shadow: var(--shadow-md);
      transform: translateY(-1px);
    }

    .btn-primary:active {
      transform: translateY(0);
      box-shadow: var(--shadow-sm);
    }

    .btn-secondary {
      background: var(--bg-primary);
      color: var(--text-primary);
      border: 1px solid var(--border-medium);
    }

    .btn-secondary:hover {
      background: var(--bg-tertiary);
      border-color: var(--neutral-600);
    }

    .btn-danger {
      background: var(--bg-primary);
      color: var(--text-secondary);
      border: 1px solid var(--border-light);
    }

    .btn-danger:hover {
      background: var(--bg-tertiary);
      border-color: var(--border-medium);
      color: var(--text-primary);
    }

    .btn-group {
      display: flex;
      gap: var(--space-sm);
    }

    .btn-sm {
      padding: 6px 14px;
      font-size: 13px;
    }

    .toggle-group {
      display: flex;
      gap: var(--space-sm);
      flex-wrap: wrap;
    }

    .toggle-btn {
      padding: 8px 16px;
      border-radius: var(--radius-full);
      font-size: 13px;
      font-weight: 500;
      background: var(--bg-secondary);
      color: var(--text-secondary);
      border: 1px solid var(--border-light);
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .toggle-btn:hover {
      background: var(--neutral-200);
    }

    .toggle-btn.active {
      background: var(--text-primary);
      color: var(--bg-primary);
      border-color: var(--text-primary);
    }

    .status-pill {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 12px;
      border-radius: var(--radius-full);
      font-size: 12px;
      font-weight: 500;
      background: var(--neutral-200);
      color: var(--text-secondary);
    }

    .status-pill.active {
      background: var(--bg-elevated);
      color: var(--text-primary);
      border: 1px solid var(--border-light);
    }

    .divider {
      height: 1px;
      background: var(--border-light);
      margin: var(--space-md) 0;
    }

    .helper-text {
      font-size: 11px;
      color: var(--text-tertiary);
      line-height: 1.5;
      margin-top: var(--space-sm);
    }

    /* Main Content */
    .main {
      flex: 1;
      padding: var(--space-lg);
      display: flex;
      flex-direction: column;
      gap: var(--space-md);
      overflow-y: auto;
      height: 100vh;
    }

    .main-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: var(--space-md);
      flex-wrap: wrap;
    }

    .main-title-group h2 {
      font-size: 24px;
      font-weight: 700;
      color: var(--text-primary);
      letter-spacing: -0.02em;
      margin-bottom: 4px;
    }

    .main-subtitle {
      font-size: 13px;
      color: var(--text-secondary);
      line-height: 1.5;
      max-width: 600px;
    }

    .mode-tabs {
      display: inline-flex;
      background: var(--bg-primary);
      border: 1px solid var(--border-light);
      border-radius: var(--radius-full);
      padding: 4px;
      box-shadow: var(--shadow-sm);
    }

    .mode-tab {
      padding: 8px 20px;
      border-radius: var(--radius-full);
      font-size: 14px;
      font-weight: 500;
      color: var(--text-secondary);
      background: transparent;
      border: none;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .mode-tab:hover {
      color: var(--text-primary);
    }

    .mode-tab.active {
      background: var(--text-primary);
      color: var(--bg-primary);
    }

    .main-grid {
      display: grid;
      grid-template-columns: 1fr 320px;
      gap: var(--space-md);
      flex: 1;
      min-height: 0;
    }

    .main-grid > .section {
      display: flex;
      flex-direction: column;
      min-height: 0;
    }

    .main-grid > .section > .card {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow-y: auto;
    }

    .chart-card {
      background: var(--bg-primary);
      border: 1px solid var(--border-light);
      border-radius: var(--radius-md);
      padding: var(--space-md);
      box-shadow: var(--shadow-md);
      display: flex;
      flex-direction: column;
      min-height: 0;
    }

    .chart-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: var(--space-sm);
      flex-shrink: 0;
    }

    .chart-title {
      font-size: 16px;
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: 2px;
    }

    .chart-description {
      font-size: 12px;
      color: var(--text-secondary);
      line-height: 1.4;
    }

    .chart-meta {
      font-size: 12px;
      color: var(--text-tertiary);
      text-align: right;
    }

    .chart-container {
      flex: 1;
      background: var(--bg-secondary);
      border: 1px solid var(--border-light);
      border-radius: var(--radius-md);
      padding: var(--space-sm);
      position: relative;
      min-height: 0;
      display: flex;
      flex-direction: column;
    }

    #timeseriesChart,
    #fftChart,
    #bandsChart {
      width: 100%;
      height: 100%;
      flex: 1;
    }

    .chart-footer {
      display: flex;
      align-items: center;
      gap: var(--space-sm);
      margin-top: var(--space-sm);
      padding-top: var(--space-sm);
      border-top: 1px solid var(--border-light);
      flex-wrap: wrap;
      flex-shrink: 0;
    }

    .badge {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 14px;
      border-radius: var(--radius-full);
      font-size: 12px;
      font-weight: 500;
      background: var(--bg-elevated);
      color: var(--text-secondary);
      border: 1px solid var(--border-light);
    }

    .badge-dot {
      width: 6px;
      height: 6px;
      border-radius: var(--radius-full);
      background: currentColor;
      animation: pulse 2s ease-in-out infinite;
    }

    .alert {
      position: fixed;
      top: 20px;
      right: 20px;
      max-width: 400px;
      padding: var(--space-md);
      border-radius: var(--radius-md);
      font-size: 13px;
      line-height: 1.6;
      display: none;
      z-index: 9999;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    }

    .alert-error {
      background: var(--bg-elevated);
      color: var(--text-primary);
      border: 1px solid var(--border-light);
    }

    .alert-success {
      background: var(--bg-elevated);
      color: var(--text-primary);
      border: 1px solid var(--border-light);
    }

    /* Toggle Switch */
    .toggle-switch {
      position: relative;
      display: inline-block;
      width: 36px;
      height: 20px;
    }

    .toggle-switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }

    .toggle-slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: var(--bg-tertiary);
      border: 1px solid var(--border-light);
      transition: 0.2s;
      border-radius: 20px;
    }

    .toggle-slider:before {
      position: absolute;
      content: "";
      height: 14px;
      width: 14px;
      left: 2px;
      bottom: 2px;
      background-color: var(--text-secondary);
      transition: 0.2s;
      border-radius: 50%;
    }

    input:checked + .toggle-slider {
      background-color: var(--text-primary);
    }

    input:checked + .toggle-slider:before {
      background-color: var(--bg-primary);
      transform: translateX(16px);
    }

    /* Custom Range Slider */
    .custom-slider {
      -webkit-appearance: none;
      appearance: none;
      height: 4px;
      background: var(--border-light);
      border-radius: var(--radius-full);
      outline: none;
    }

    .custom-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 16px;
      height: 16px;
      background: var(--text-primary);
      border-radius: 50%;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .custom-slider::-webkit-slider-thumb:hover {
      transform: scale(1.1);
    }

    .custom-slider::-moz-range-thumb {
      width: 16px;
      height: 16px;
      background: var(--text-primary);
      border: none;
      border-radius: 50%;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .custom-slider::-moz-range-thumb:hover {
      transform: scale(1.1);
    }

    .custom-slider::-moz-range-track {
      background: var(--border-light);
      border-radius: var(--radius-full);
      height: 4px;
    }

    /* Camera/FaceSynth Feature Meters */
    .feature-meter {
      display: flex;
      flex-direction: column;
      gap: 4px;
      padding: 8px;
      background: var(--bg-secondary);
      border: 1px solid var(--border-light);
      border-radius: var(--radius-sm);
    }

    .progress-bar {
      width: 100%;
      height: 6px;
      background: var(--bg-tertiary);
      border-radius: var(--radius-full);
      overflow: hidden;
      position: relative;
    }

    .progress-fill {
      height: 100%;
      background: var(--text-primary);
      border-radius: var(--radius-full);
      transition: width 0.1s ease-out;
      width: 0%;
    }

    .feature-value {
      font-size: 20px;
      font-weight: 600;
      color: var(--text-primary);
      text-align: center;
      font-variant-numeric: tabular-nums;
    }

    /* Responsive */
    @media (max-width: 1024px) {
      .main-grid {
        grid-template-columns: 1fr;
      }
    }

    @media (max-width: 768px) {
      body {
        flex-direction: column;
      }

      .sidebar {
        width: 100%;
        border-right: none;
        border-bottom: 1px solid var(--border-light);
        padding: var(--space-lg);
      }

      .main {
        padding: var(--space-lg);
      }

      .main-title-group h2 {
        font-size: 24px;
      }

      .chart-container {
        height: 320px;
      }
    }
  </style>
</head>
<body>
  <aside class="sidebar">
    <div class="brand">
      <div class="brand-header">
        <div class="brand-logo">B</div>
        <div class="brand-text">
          <h1>BioMus</h1>
          <div class="tagline">Biosignal Creative Platform</div>
        </div>
      </div>
      <div class="brand-credit">EEG · CV · OSC</div>
    </div>

    <div class="section">
      <div class="section-label">Quick Start</div>

      <!-- Global Messages -->
      <div id="global-error" class="alert alert-error"></div>
      <div id="global-success" class="alert alert-success"></div>

      <!-- Step 1: Connect -->
      <div class="card">
        <div class="card-header">
          <div class="step-badge">1</div>
          <div class="card-title-group">
            <div class="card-title">Connect EEG</div>
            <div class="card-subtitle" id="status-subtext">Ready to connect</div>
          </div>
          <div class="status-indicator" id="status-dot"></div>
        </div>

        <div class="info-box">
          <strong>Bluetooth:</strong> Leave empty and click Connect<br>
          <strong>Serial:</strong> Enter port (e.g., /dev/tty.usbmodem14101)
        </div>

        <div class="field-group">
          <input
            id="serial-input"
            type="text"
            placeholder="Serial port (optional for Bluetooth)"
          />
        </div>

        <div class="btn-group">
          <button id="btn-connect" class="btn btn-primary" style="flex: 1;">
            Connect
          </button>
          <button id="btn-disconnect" class="btn btn-danger">
            Disconnect
          </button>
        </div>
      </div>

      <!-- Step 2: Stream -->
      <div class="card">
        <div class="card-header">
          <div class="step-badge">2</div>
          <div class="card-title-group">
            <div class="card-title">Start Streaming</div>
            <div class="card-subtitle">
              <span id="stream-pill" class="status-pill">Ready</span>
              <span id="camera-pill" class="status-pill" style="margin-left: 8px;">Camera: Ready</span>
            </div>
          </div>
        </div>

        <div class="field-group">
          <label class="field-label">EEG Stream</label>
          <div class="btn-group">
            <button id="btn-start" class="btn btn-primary" style="flex: 1;">
              Start EEG
            </button>
            <button id="btn-stop" class="btn btn-secondary">
              Stop
            </button>
          </div>
        </div>

        <div class="divider"></div>

        <div class="field-group" style="margin-bottom: 0;">
          <label class="field-label">Camera Stream</label>
          <div class="btn-group">
            <button id="btn-camera-start" class="btn btn-primary" style="flex: 1;">
              Start Camera
            </button>
            <button id="btn-camera-stop" class="btn btn-secondary">
              Stop
            </button>
          </div>
        </div>
      </div>
    </div>

  </aside>

  <main class="main">
    <header class="main-header">
      <div class="main-title-group">
        <h2>Signal Monitor</h2>
        <p class="main-subtitle">
          Real-time biosignal visualization with EEG analysis and facial feature tracking for creative control.
        </p>
      </div>
      <div class="mode-tabs">
        <button id="tab-timeseries" class="mode-tab active">Time Series</button>
        <button id="tab-fft" class="mode-tab">FFT</button>
        <button id="tab-bands" class="mode-tab">Bands</button>
        <button id="tab-camera" class="mode-tab">Camera</button>
      </div>
    </header>

    <section class="main-grid">
      <div class="chart-card">
        <div class="chart-header">
          <div>
            <div class="chart-title" id="visual-title">Time Series</div>
            <div class="chart-description" id="visual-subtitle">
              4-channel windowed EEG traces with temporal dynamics
            </div>
          </div>
          <div class="chart-meta" id="visual-meta">
            Mode: timeseries · Window: 4s
          </div>
        </div>

        <div class="chart-container">
          <canvas id="timeseriesChart"></canvas>
          <canvas id="fftChart" style="display:none;"></canvas>
          <canvas id="bandsChart" style="display:none;"></canvas>
          <div id="cameraView" style="display:none; width: 100%; flex: 1; position: relative; min-height: 0; max-height: 100%; overflow: hidden;">
            <img id="cameraFeed" style="width: 100%; height: 100%; object-fit: cover; object-position: center; border-radius: 8px;" />
          </div>
        </div>

        <div id="cameraFeatures" style="display:none; margin-top: var(--space-sm); padding-top: var(--space-sm); border-top: 1px solid var(--border-light); flex-shrink: 0;">
          <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: var(--space-sm);">
            <div class="feature-meter">
              <div class="field-label">Mouth</div>
              <div class="progress-bar"><div id="meter-mouth" class="progress-fill"></div></div>
              <div class="feature-value"><span id="val-mouth">0.00</span></div>
            </div>
            <div class="feature-meter">
              <div class="field-label">Roll</div>
              <div class="progress-bar"><div id="meter-roll" class="progress-fill"></div></div>
              <div class="feature-value"><span id="val-roll">0.00</span></div>
            </div>
            <div class="feature-meter">
              <div class="field-label">Smile</div>
              <div class="progress-bar"><div id="meter-smile" class="progress-fill"></div></div>
              <div class="feature-value"><span id="val-smile">0.00</span></div>
            </div>
          </div>
        </div>

        <div class="chart-footer">
          <div class="badge">
            <span class="badge-dot"></span>
            <span id="chip-mode">Streaming: time series</span>
          </div>
          <div class="badge">
            OSC: <span id="chip-osc">disabled</span>
          </div>
          <div id="scale-controls" style="margin-left: auto; display: flex; align-items: center; gap: 16px;">
            <div style="display: flex; align-items: center; gap: 8px;">
              <label style="font-size: 12px; color: var(--text-secondary); font-weight: 500;">Auto</label>
              <label class="toggle-switch">
                <input type="checkbox" id="auto-scale-toggle">
                <span class="toggle-slider"></span>
              </label>
            </div>
            <div style="display: flex; align-items: center; gap: 8px;">
              <label style="font-size: 12px; color: var(--text-secondary); font-weight: 500;">Y-Scale:</label>
              <input type="range" id="scale-slider" min="25" max="10000" value="100" step="25" class="custom-slider" style="width: 120px; cursor: pointer;">
              <span id="scale-value" style="font-size: 12px; color: var(--text-primary); font-weight: 500; min-width: 60px;">±100</span>
            </div>
          </div>
        </div>

        <div id="error-msg" class="alert alert-error"></div>
      </div>

      <div class="section">
        <div class="section-label">OSC Output</div>
        <div class="card">
          <div class="field-group">
            <label class="field-label">Target Address</label>
            <div class="input-row">
              <input id="osc-ip" type="text" value="127.0.0.1" placeholder="IP Address" />
              <input id="osc-port" type="number" value="9000" placeholder="Port" style="max-width: 100px;" />
            </div>
          </div>

          <div class="field-group">
            <label class="field-label">EEG Data Format</label>
            <div class="toggle-group">
              <button id="osc-raw-toggle" class="toggle-btn active">Timeseries</button>
              <button id="osc-bands-toggle" class="toggle-btn">Bands</button>
            </div>
          </div>

          <div class="field-group">
            <label class="field-label">Camera CV</label>
            <div class="toggle-group">
              <button id="osc-camera-toggle" class="toggle-btn active">FaceSynth</button>
            </div>
            <div class="helper-text" style="margin-top: 8px;">
              Sends facial features to /faceSynth/* and /cv/face/*
            </div>
          </div>

          <div class="divider"></div>

          <div class="helper-text">
            Stream biosignals via OSC to creative applications (Max/MSP, TouchDesigner, Pure Data, Ableton, etc.)
          </div>

          <div style="margin-top: var(--space-md);">
            <button id="osc-enable-btn" class="btn btn-secondary">
              Enable OSC
            </button>
          </div>
        </div>
      </div>
    </section>
  </main>

  <script>
    // Stream configuration constants - optimized for real-time EEG visualization
    const WINDOW_SEC = 4.0;  // 4 seconds provides good balance of temporal/frequency resolution
    const UPDATE_INTERVAL_MS = 50;  // 50ms = 20 updates/second for smooth visualization

    let ws = null;
    let cameraWs = null;
    let currentMode = "timeseries";
    let connected = false;
    let streaming = false;
    let cameraRunning = false;
    let oscEnabled = false;
    let oscSendRaw = true;
    let oscSendBands = false;

    const statusDot = document.getElementById("status-dot");
    const statusSub = document.getElementById("status-subtext");
    const streamPill = document.getElementById("stream-pill");
    const cameraPill = document.getElementById("camera-pill");
    const chipMode = document.getElementById("chip-mode");
    const chipOsc = document.getElementById("chip-osc");
    const globalError = document.getElementById("global-error");
    const globalSuccess = document.getElementById("global-success");
    const errorMsg = document.getElementById("error-msg");
    const visualTitle = document.getElementById("visual-title");
    const visualSubtitle = document.getElementById("visual-subtitle");
    const visualMeta = document.getElementById("visual-meta");

    function showError(message) {
      globalError.textContent = message;
      globalError.style.display = "block";
      globalSuccess.style.display = "none";
      setTimeout(() => {
        globalError.style.display = "none";
      }, 8000);
    }

    function showSuccess(message) {
      globalSuccess.textContent = message;
      globalSuccess.style.display = "block";
      globalError.style.display = "none";
      setTimeout(() => {
        globalSuccess.style.display = "none";
      }, 5000);
    }

    function hideMessages() {
      globalError.style.display = "none";
      globalSuccess.style.display = "none";
    }

    function setStatus() {
      if (connected) {
        statusDot.classList.add("connected");
        statusSub.textContent = streaming ? "Streaming active" : "Connected";
      } else {
        statusDot.classList.remove("connected");
        statusSub.textContent = "Ready to connect";
      }
      if (streaming) {
        streamPill.textContent = "Streaming";
        streamPill.classList.add("active");
      } else {
        streamPill.textContent = connected ? "Ready" : "Idle";
        streamPill.classList.remove("active");
      }
      if (cameraRunning) {
        cameraPill.textContent = "Streaming";
        cameraPill.classList.add("active");
      } else {
        cameraPill.textContent = "Ready";
        cameraPill.classList.remove("active");
      }
      chipMode.textContent = streaming
        ? `Streaming: ${currentMode === "timeseries" ? "time series" : currentMode === "fft" ? "FFT" : currentMode === "camera" ? "camera" : "frequency bands"}`
        : "Streaming: stopped";
    }

    function setOscChip() {
      chipOsc.textContent = oscEnabled
        ? `enabled (${[
            oscSendRaw ? "raw" : null,
            oscSendBands ? "bands" : null,
          ].filter(Boolean).join(" + ")})`
        : "disabled";
    }

    async function postJSON(url, data) {
      const res = await fetch(url, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(data || {}),
      });
      return res.json();
    }

    async function refreshStatus() {
      const res = await fetch("/api/status");
      const json = await res.json();
      connected = json.connected;
      streaming = json.streaming;
      setStatus();
    }

    // Connect button
    document.getElementById("btn-connect").onclick = async () => {
      const input = document.getElementById("serial-input").value.trim();
      const btn = document.getElementById("btn-connect");

      hideMessages();

      let payload, deviceType;
      if (!input) {
        payload = { serial_port: "", mac_address: "" };
        deviceType = "Native Bluetooth";
      } else if (input.includes(":")) {
        payload = { serial_port: "", mac_address: input };
        deviceType = "Bluetooth (MAC)";
      } else {
        payload = { serial_port: input, mac_address: "" };
        deviceType = "Serial (BLED112)";
      }

      btn.disabled = true;
      btn.textContent = "Connecting...";

      try {
        const json = await postJSON("/api/connect", payload);

        if (json.status === "ok") {
          connected = true;
          showSuccess(`Connected via ${deviceType}! Now click 'Start Stream' to begin.`);
        } else {
          connected = false;
          let troubleshoot = input.includes("/dev/")
            ? "Check that EEG device is powered on and USB dongle is connected."
            : "Turn on EEG device and ensure Bluetooth is enabled.";
          showError(`Connection failed: ${json.message || "Unknown error"}\n\n${troubleshoot}`);
        }
      } catch (error) {
        showError(`Failed to connect: ${error.message}`);
      } finally {
        btn.disabled = false;
        btn.textContent = "Connect";
        setStatus();
      }
    };

    document.getElementById("btn-disconnect").onclick = async () => {
      await postJSON("/api/disconnect", {});
      connected = false;
      streaming = false;
      closeWS();
      showSuccess("Disconnected successfully");
      setStatus();
    };

    document.getElementById("btn-start").onclick = async () => {
      if (!connected) {
        showError("Please connect to the device first");
        return;
      }

      hideMessages();
      const json = await postJSON("/api/start", {});
      if (json.status === "ok") {
        streaming = true;
        openWS();
        showSuccess("Streaming started successfully");
      } else {
        showError(`Failed to start stream: ${json.message || "Unknown error"}`);
      }
      setStatus();
    };

    document.getElementById("btn-stop").onclick = async () => {
      await postJSON("/api/stop", {});
      streaming = false;
      closeWS();
      showSuccess("Stream stopped");
      setStatus();
    };

    // Camera buttons
    document.getElementById("btn-camera-start").onclick = async () => {
      hideMessages();
      try {
        const json = await postJSON("/api/camera/start", { camera_index: 0 });
        if (json.status === "ok") {
          cameraRunning = true;
          openCameraWS();
          showSuccess("Camera started successfully");
        } else {
          showError(`Failed to start camera: ${json.message || "Unknown error"}`);
        }
      } catch (error) {
        showError(`Failed to start camera: ${error.message}`);
      }
      setStatus();
    };

    document.getElementById("btn-camera-stop").onclick = async () => {
      await postJSON("/api/camera/stop", {});
      cameraRunning = false;
      closeCameraWS();
      showSuccess("Camera stopped");
      setStatus();
    };

    // OSC toggles
    const oscRawToggle = document.getElementById("osc-raw-toggle");
    const oscBandsToggle = document.getElementById("osc-bands-toggle");
    const oscEnableBtn = document.getElementById("osc-enable-btn");

    oscRawToggle.onclick = () => {
      oscSendRaw = !oscSendRaw;
      oscRawToggle.classList.toggle("active", oscSendRaw);
      pushOscConfig();
    };

    oscBandsToggle.onclick = () => {
      oscSendBands = !oscSendBands;
      oscBandsToggle.classList.toggle("active", oscSendBands);
      pushOscConfig();
    };

    oscEnableBtn.onclick = () => {
      oscEnabled = !oscEnabled;
      oscEnableBtn.textContent = oscEnabled ? "Disable OSC" : "Enable OSC";
      pushOscConfig();
    };

    async function pushOscConfig() {
      const ip = document.getElementById("osc-ip").value.trim() || "127.0.0.1";
      const port = parseInt(document.getElementById("osc-port").value.trim() || "9000", 10);
      await postJSON("/api/osc_config", {
        ip,
        port,
        enabled: oscEnabled,
        send_raw: oscSendRaw,
        send_bands: oscSendBands,
      });
      setOscChip();
    }

    // Mode tabs
    const tabTS = document.getElementById("tab-timeseries");
    const tabFFT = document.getElementById("tab-fft");
    const tabBands = document.getElementById("tab-bands");
    const tabCamera = document.getElementById("tab-camera");
    tabTS.onclick = () => switchMode("timeseries");
    tabFFT.onclick = () => switchMode("fft");
    tabBands.onclick = () => switchMode("bands");
    tabCamera.onclick = () => switchMode("camera");

    function switchMode(mode) {
      if (mode === currentMode) return;
      currentMode = mode;
      tabTS.classList.toggle("active", mode === "timeseries");
      tabFFT.classList.toggle("active", mode === "fft");
      tabBands.classList.toggle("active", mode === "bands");
      tabCamera.classList.toggle("active", mode === "camera");

      // Show/hide scale controls based on mode
      const scaleControls = document.getElementById("scale-controls");
      if (scaleControls) {
        scaleControls.style.display = mode === "camera" ? "none" : "flex";
      }

      if (mode === "timeseries") {
        visualTitle.textContent = "Time Series";
        visualSubtitle.textContent = "Real-time biosignal traces with temporal dynamics";
        document.getElementById("timeseriesChart").style.display = "block";
        document.getElementById("fftChart").style.display = "none";
        document.getElementById("bandsChart").style.display = "none";
        document.getElementById("cameraView").style.display = "none";
        document.getElementById("cameraFeatures").style.display = "none";
      } else if (mode === "fft") {
        visualTitle.textContent = "FFT Spectrum";
        visualSubtitle.textContent = "Real-time frequency domain analysis using Fast Fourier Transform";
        document.getElementById("timeseriesChart").style.display = "none";
        document.getElementById("fftChart").style.display = "block";
        document.getElementById("bandsChart").style.display = "none";
        document.getElementById("cameraView").style.display = "none";
        document.getElementById("cameraFeatures").style.display = "none";
      } else if (mode === "camera") {
        visualTitle.textContent = "Camera / FaceSynth";
        visualSubtitle.textContent = "Real-time facial feature tracking with OSC output";
        document.getElementById("timeseriesChart").style.display = "none";
        document.getElementById("fftChart").style.display = "none";
        document.getElementById("bandsChart").style.display = "none";
        document.getElementById("cameraView").style.display = "block";
        document.getElementById("cameraFeatures").style.display = "block";
      } else {
        visualTitle.textContent = "Frequency Bands";
        visualSubtitle.textContent = "Per-channel power distribution across delta, theta, alpha, beta, and gamma bands";
        document.getElementById("timeseriesChart").style.display = "none";
        document.getElementById("fftChart").style.display = "none";
        document.getElementById("bandsChart").style.display = "block";
        document.getElementById("cameraView").style.display = "none";
        document.getElementById("cameraFeatures").style.display = "none";
      }

      visualMeta.textContent = `Mode: ${mode} · Window: ${WINDOW_SEC.toFixed(1)}s`;

      if (ws && mode !== "camera") {
        ws.send(
          JSON.stringify({
            mode,
            window_sec: WINDOW_SEC,
            interval_ms: UPDATE_INTERVAL_MS,
          })
        );
      }
      setStatus();
    }

    // Charts with Eleven Labs inspired colors
    const tsCtx = document.getElementById("timeseriesChart").getContext("2d");
    const fftCtx = document.getElementById("fftChart").getContext("2d");
    const bandsCtx = document.getElementById("bandsChart").getContext("2d");

    const chartColors = [
      "#2AA3FE", // Blue
      "#10B978", // Green
      "#B743C6", // Purple
      "#F58633", // Orange
    ];

    // Smart adaptive scaling with smoothing to reduce jitter
    let tsYMin = -100, tsYMax = 100;
    let fftYMin = -40, fftYMax = 10;
    let bandsYMax = 50;

    let tsChart = new Chart(tsCtx, {
      type: "line",
      data: {
        labels: [],
        datasets: [],
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        animation: {
          duration: 100,
          easing: 'linear'
        },
        scales: {
          x: {
            ticks: {
              color: "#666666",
              font: { family: 'Inter' }
            },
            grid: { color: "rgba(0, 0, 0, 0.06)" },
          },
          y: {
            ticks: {
              color: "#666666",
              font: { family: 'Inter' }
            },
            grid: { color: "rgba(0, 0, 0, 0.06)" },
          },
        },
        interaction: {
          mode: 'nearest',
          intersect: false
        },
        plugins: {
          legend: {
            labels: {
              color: "#999999",
              usePointStyle: true,
              font: { family: 'Inter', weight: '500' }
            },
          },
          decimation: {
            enabled: true,
            algorithm: 'lttb',
            samples: 500
          }
        },
        elements: {
          line: {
            tension: 0.4,
            borderWidth: 2.5,
          },
          point: { radius: 0 },
        },
      },
    });

    let fftChart = new Chart(fftCtx, {
      type: "line",
      data: {
        labels: [],
        datasets: [],
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        animation: {
          duration: 150,
          easing: 'linear'
        },
        scales: {
          x: {
            ticks: {
              color: "#666666",
              font: { family: 'Inter' }
            },
            grid: { color: "rgba(0, 0, 0, 0.06)" },
            title: {
              display: true,
              text: 'Frequency (Hz)',
              color: "#999999",
              font: { family: 'Inter', weight: '500' }
            }
          },
          y: {
            ticks: {
              color: "#666666",
              font: { family: 'Inter' }
            },
            grid: { color: "rgba(0, 0, 0, 0.06)" },
            title: {
              display: true,
              text: 'Power Spectral Density (dB)',
              color: "#999999",
              font: { family: 'Inter', weight: '500' }
            }
          },
        },
        interaction: {
          mode: 'nearest',
          intersect: false
        },
        plugins: {
          legend: {
            labels: {
              color: "#999999",
              usePointStyle: true,
              font: { family: 'Inter', weight: '500' }
            },
          },
        },
        elements: {
          line: {
            tension: 0.1,
            borderWidth: 2,
          },
          point: { radius: 0 },
        },
      },
    });

    let bandsChart = new Chart(bandsCtx, {
      type: "bar",
      data: {
        labels: [],
        datasets: [],
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        animation: {
          duration: 200,
          easing: 'easeInOutQuad'
        },
        scales: {
          x: {
            ticks: {
              color: "#666666",
              font: { family: 'Inter', size: 11 }
            },
            grid: { color: "rgba(0, 0, 0, 0.06)" },
          },
          y: {
            beginAtZero: true,
            ticks: {
              color: "#666666",
              font: { family: 'Inter' }
            },
            grid: { color: "rgba(0, 0, 0, 0.06)" },
            title: {
              display: true,
              text: 'Power (%)',
              color: "#999999",
              font: { family: 'Inter', weight: '500' }
            }
          },
        },
        plugins: {
          legend: {
            labels: {
              color: "#999999",
              usePointStyle: true,
              font: { family: 'Inter', weight: '500' }
            },
          },
        },
      },
    });

    // Scale mode state
    let autoScaleEnabled = false;
    let scaleValue = 100; // Default to ±100

    const scaleSlider = document.getElementById('scale-slider');
    const scaleValueDisplay = document.getElementById('scale-value');
    const autoScaleToggle = document.getElementById('auto-scale-toggle');

    // Slider handler
    if (scaleSlider && scaleValueDisplay) {
      scaleSlider.addEventListener('input', (e) => {
        scaleValue = parseInt(e.target.value);
        scaleValueDisplay.textContent = `±${scaleValue}`;
      });
    }

    // Auto-scale toggle handler
    if (autoScaleToggle && scaleSlider) {
      autoScaleToggle.addEventListener('change', (e) => {
        autoScaleEnabled = e.target.checked;
        scaleSlider.disabled = autoScaleEnabled;
        scaleSlider.style.opacity = autoScaleEnabled ? '0.5' : '1';
      });
    }

    function updateTimeSeriesChart(channels, data) {
      if (!data || data.length === 0) return;
      const n = data[0].length;
      const labels = Array.from({ length: n }, (_, i) => i.toString());

      // Apply scaling based on auto-scale toggle
      if (autoScaleEnabled) {
        // Calculate adaptive range with smoothing
        let dataMin = Infinity, dataMax = -Infinity;
        data.forEach(channelData => {
          channelData.forEach(val => {
            if (val < dataMin) dataMin = val;
            if (val > dataMax) dataMax = val;
          });
        });

        // Smooth the min/max with exponential moving average (reduces jitter)
        const alpha = 0.15; // Lower = smoother, higher = more responsive
        tsYMin = tsYMin * (1 - alpha) + dataMin * alpha;
        tsYMax = tsYMax * (1 - alpha) + dataMax * alpha;

        // Add 10% padding
        const range = tsYMax - tsYMin;
        const padding = range * 0.1;

        tsChart.options.scales.y.min = tsYMin - padding;
        tsChart.options.scales.y.max = tsYMax + padding;
      } else {
        // Fixed scale mode using slider value
        tsChart.options.scales.y.min = -scaleValue;
        tsChart.options.scales.y.max = scaleValue;
      }

      tsChart.data.labels = labels;

      if (tsChart.data.datasets.length !== channels.length) {
        tsChart.data.datasets = channels.map((chName, idx) => ({
          label: chName,
          data: data[idx],
          borderColor: chartColors[idx % chartColors.length],
          backgroundColor: "transparent",
        }));
      } else {
        channels.forEach((_, idx) => {
          tsChart.data.datasets[idx].data = data[idx];
        });
      }
      tsChart.update("none");
    }

    function updateFFTChart(channels, freqs, psd) {
      if (!psd || psd.length === 0 || !freqs || freqs.length === 0) return;

      // Apply scaling based on auto-scale toggle
      if (autoScaleEnabled) {
        // Calculate adaptive range with smoothing
        let dataMin = Infinity, dataMax = -Infinity;
        psd.forEach(channelData => {
          channelData.forEach(val => {
            if (val < dataMin) dataMin = val;
            if (val > dataMax) dataMax = val;
          });
        });

        // Smooth the min/max
        const alpha = 0.15;
        fftYMin = fftYMin * (1 - alpha) + dataMin * alpha;
        fftYMax = fftYMax * (1 - alpha) + dataMax * alpha;

        // Add padding
        const range = fftYMax - fftYMin;
        const padding = range * 0.1;

        fftChart.options.scales.y.min = fftYMin - padding;
        fftChart.options.scales.y.max = fftYMax + padding;
      } else {
        // Fixed scale mode for FFT using slider value
        fftChart.options.scales.y.min = 0;
        fftChart.options.scales.y.max = scaleValue;
      }

      fftChart.data.labels = freqs.map(f => f.toFixed(1));

      if (fftChart.data.datasets.length !== channels.length) {
        fftChart.data.datasets = channels.map((chName, idx) => ({
          label: chName,
          data: psd[idx],
          borderColor: chartColors[idx % chartColors.length],
          backgroundColor: "transparent",
        }));
      } else {
        channels.forEach((_, idx) => {
          fftChart.data.datasets[idx].data = psd[idx];
        });
      }
      fftChart.update("none");
    }

    function updateBandsChart(channels, bandNames, values) {
      if (!values || values.length === 0) return;

      // Apply scaling based on auto-scale toggle
      if (autoScaleEnabled) {
        // Calculate adaptive max with smoothing
        let dataMax = 0;
        values.forEach(channelData => {
          channelData.forEach(val => {
            if (val > dataMax) dataMax = val;
          });
        });

        // Smooth the max
        const alpha = 0.15;
        bandsYMax = bandsYMax * (1 - alpha) + dataMax * alpha;

        // Add padding and ensure minimum range
        const paddedMax = Math.max(bandsYMax * 1.2, 10);

        bandsChart.options.scales.y.max = paddedMax;
      } else {
        // Fixed scale mode for bands using slider value
        bandsChart.options.scales.y.min = 0;
        bandsChart.options.scales.y.max = scaleValue;
      }

      bandsChart.data.labels = bandNames;

      if (bandsChart.data.datasets.length !== channels.length) {
        bandsChart.data.datasets = channels.map((chName, idx) => ({
          label: chName,
          data: values[idx],
          backgroundColor: chartColors[idx % chartColors.length] + "B3", // 70% opacity
        }));
      } else {
        channels.forEach((_, idx) => {
          bandsChart.data.datasets[idx].data = values[idx];
        });
      }
      bandsChart.update("none");
    }

    // WebSocket
    function openWS() {
      if (ws) return;
      const proto = window.location.protocol === "https:" ? "wss" : "ws";
      const url = `${proto}://${window.location.host}/ws/stream`;
      ws = new WebSocket(url);

      ws.onopen = () => {
        ws.send(
          JSON.stringify({
            mode: currentMode,
            window_sec: WINDOW_SEC,
            interval_ms: UPDATE_INTERVAL_MS,
          })
        );
        errorMsg.style.display = "none";
      };

      ws.onmessage = (event) => {
        const msg = JSON.parse(event.data);
        if (msg.type === "timeseries") {
          updateTimeSeriesChart(msg.channels, msg.data);
        } else if (msg.type === "fft") {
          updateFFTChart(msg.channels, msg.freqs, msg.psd);
        } else if (msg.type === "bands") {
          updateBandsChart(msg.channels, msg.bands, msg.values);
        } else if (msg.type === "error") {
          errorMsg.textContent = msg.message || "Stream error.";
          errorMsg.style.display = "block";
        }
      };

      ws.onclose = () => {
        ws = null;
      };

      ws.onerror = () => {
        errorMsg.textContent = "WebSocket error.";
        errorMsg.style.display = "block";
      };
    }

    function closeWS() {
      if (ws) {
        ws.close();
        ws = null;
      }
    }

    // Camera WebSocket
    function openCameraWS() {
      if (cameraWs) return;
      const proto = window.location.protocol === "https:" ? "wss" : "ws";
      const url = `${proto}://${window.location.host}/ws/camera`;
      cameraWs = new WebSocket(url);

      cameraWs.onmessage = (event) => {
        const msg = JSON.parse(event.data);
        if (msg.type === "camera") {
          // Update camera feed
          const img = document.getElementById("cameraFeed");
          img.src = "data:image/jpeg;base64," + msg.frame;

          // Update facial features (only mouth, roll, smile)
          const features = msg.features;
          updateFeatureMeter("mouth", features.mouth_openness || 0);
          updateFeatureMeter("roll", (features.head_roll || 0) / 30 + 0.5); // Map -15 to 15 -> 0 to 1
          updateFeatureMeter("smile", features.smile_curvature || 0);
        } else if (msg.type === "error") {
          errorMsg.textContent = msg.message || "Camera error.";
          errorMsg.style.display = "block";
        }
      };

      cameraWs.onclose = () => {
        cameraWs = null;
      };

      cameraWs.onerror = () => {
        errorMsg.textContent = "Camera WebSocket error.";
        errorMsg.style.display = "block";
      };
    }

    function closeCameraWS() {
      if (cameraWs) {
        cameraWs.close();
        cameraWs = null;
      }
    }

    function updateFeatureMeter(name, value) {
      // Clamp value between 0 and 1
      value = Math.max(0, Math.min(1, value));

      const meter = document.getElementById(`meter-${name}`);
      const valueSpan = document.getElementById(`val-${name}`);

      if (meter) {
        meter.style.width = `${value * 100}%`;
      }
      if (valueSpan) {
        valueSpan.textContent = value.toFixed(2);
      }
    }

    // Initial status check
    refreshStatus();
    setOscChip();
  </script>
</body>
</html>
